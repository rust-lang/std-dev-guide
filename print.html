<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Standard library developers Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Guide for standard library developers">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">1.</strong> About this Guide</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Contributing to the standard libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/building-and-debugging.html"><strong aria-hidden="true">2.1.</strong> Building and debugging</a></li><li class="chapter-item expanded "><a href="development/perf-benchmarking.html"><strong aria-hidden="true">2.2.</strong> Performance optimizations and benchmarking</a></li><li class="chapter-item expanded "><a href="development/how-to-write-documentation.html"><strong aria-hidden="true">2.3.</strong> Writing documentation</a></li><li class="chapter-item expanded "><a href="development/feature-lifecycle.html"><strong aria-hidden="true">2.4.</strong> Feature lifecycle</a></li><li class="chapter-item expanded "><a href="development/stabilization.html"><strong aria-hidden="true">2.5.</strong> Stabilizing a feature</a></li></ol></li><li class="chapter-item expanded "><a href="breaking-changes/summary.html"><strong aria-hidden="true">3.</strong> Breaking changes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="breaking-changes/new-trait-impls.html"><strong aria-hidden="true">3.1.</strong> New trait implementations</a></li><li class="chapter-item expanded "><a href="breaking-changes/prelude.html"><strong aria-hidden="true">3.2.</strong> Prelude</a></li><li class="chapter-item expanded "><a href="breaking-changes/doc-changes.html"><strong aria-hidden="true">3.3.</strong> Doc changes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Policies</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="policy/must-use.html"><strong aria-hidden="true">4.1.</strong> When to add #[must_use]</a></li><li class="chapter-item expanded "><a href="policy/specialization.html"><strong aria-hidden="true">4.2.</strong> Specialization</a></li><li class="chapter-item expanded "><a href="policy/inline.html"><strong aria-hidden="true">4.3.</strong> When to #[inline]</a></li><li class="chapter-item expanded "><a href="policy/doc-alias.html"><strong aria-hidden="true">4.4.</strong> Doc alias policy</a></li><li class="chapter-item expanded "><a href="policy/safety-comments.html"><strong aria-hidden="true">4.5.</strong> Safety comments policy</a></li><li class="chapter-item expanded "><a href="policy/target-code.html"><strong aria-hidden="true">4.6.</strong> Reviewing target-specific code</a></li><li class="chapter-item expanded "><a href="policy/extension-traits.html"><strong aria-hidden="true">4.7.</strong> Why the standard library uses extension traits</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Tricky situations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="tricky/may-dangle.html"><strong aria-hidden="true">5.1.</strong> Drop and #[may_dangle]</a></li><li class="chapter-item expanded "><a href="tricky/generics-and-unsafe.html"><strong aria-hidden="true">5.2.</strong> Generics and unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="team/summary.html"><strong aria-hidden="true">6.</strong> The library team</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="team/meetings.html"><strong aria-hidden="true">6.1.</strong> Meetings</a></li><li class="chapter-item expanded "><a href="team/membership.html"><strong aria-hidden="true">6.2.</strong> Membership</a></li><li class="chapter-item expanded "><a href="team/reviewing.html"><strong aria-hidden="true">6.3.</strong> Reviewing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Standard library developers Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/std-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-guide"><a class="header" href="#about-this-guide">About this Guide</a></h1>
<p>Welcome to the std dev guide.</p>
<p>This guide is maintained by the library team.</p>
<p>The guide is not very complete yet.
Contributions to this guide are very welcome.</p>
<p>Other useful documentation:</p>
<ul>
<li><a href="https://forge.rust-lang.org/">https://forge.rust-lang.org/</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">https://rustc-dev-guide.rust-lang.org/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-debugging-the-library-crates"><a class="header" href="#building-and-debugging-the-library-crates">Building and Debugging the library crates</a></h1>
<p>Most of the <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">instructions from the rustc-dev-guide</a> also apply to the standard library since
it is built with the same build system, so it is recommended to read it first.</p>
<h1 id="println-debugging-alloc-and-core"><a class="header" href="#println-debugging-alloc-and-core">Println-debugging alloc and core</a></h1>
<p>Since logging and IO APIs are not available in <code>alloc</code> and <code>core</code> advice meant for the rest of the compiler
is not applicable here.</p>
<p>Instead one can either extract the code that should be tested to a normal crate and add debugging statements there or
on POSIX systems one can use the following hack:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn dprintf(fd: i32, s: *const u8, ...);
}

macro_rules! dbg_printf {
    ($s:expr) =&gt; {
        unsafe { dprintf(2, &quot;%s\0&quot;.as_ptr(), $s as *const u8); }
    }
}

fn function_to_debug() {
    let dbg_str = format!(&quot;debug: {}\n\0&quot;, &quot;hello world&quot;);
    dbg_printf!(dbg_str.as_bytes().as_ptr());
}
<span class="boring">}</span></code></pre></pre>
<p>Then one can run a test which exercises the code to debug and show the error output via</p>
<pre><code class="language-shell ignore">./x.py test library/alloc --test-args &lt;test_name&gt; --test-args --nocapture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-optimizations-and-benchmarking"><a class="header" href="#library-optimizations-and-benchmarking">Library optimizations and benchmarking</a></h1>
<p>Recommended reading: <a href="https://nnethercote.github.io/perf-book/title-page.html">The Rust performance book</a></p>
<h2 id="what-to-optimize"><a class="header" href="#what-to-optimize">What to optimize</a></h2>
<p>It's preferred to optimize code that shows up as significant in real-world code.
E.g. it's more beneficial to speed up <code>[T]::sort</code> than it is to shave off a small allocation in <code>Command::spawn</code>
because the latter is dominated by its syscall cost.</p>
<p>Issues about slow library code are labeled as <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AI-slow+label%3AT-libs">I-slow T-libs</a>
and those about code size as <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AI-heavy+label%3AT-libs">I-heavy T-libs</a></p>
<h2 id="vectorization"><a class="header" href="#vectorization">Vectorization</a></h2>
<p>Currently only baseline target features (e.g. SSE2 on x86_64-unknown-linux-gnu) can be used in core and alloc because
runtime feature-detection is only available in std.
Where possible the preferred way to achieve vectorization is by shaping code in a way that the compiler
backend's auto-vectorization passes can understand. This benefits user crates compiled with additional target features
when they instantiate generic library functions, e.g. iterators.</p>
<h2 id="rustc-perf"><a class="header" href="#rustc-perf">rustc-perf</a></h2>
<p>For parts of the standard library that are heavily used by rustc itself it can be convenient to use
<a href="https://github.com/rust-lang/rustc-perf/tree/master/collector#benchmarking">the benchmark server</a>.</p>
<p>Since it only measures compile-time but not runtime performance of crates it can't be used to benchmark for features
that aren't used by the compiler, e.g. floating point code, linked lists, mpsc channels, etc.
For those explicit benchmarks must be written or extracted from real-world code.</p>
<h2 id="built-in-microbenchmarks"><a class="header" href="#built-in-microbenchmarks">Built-in Microbenchmarks</a></h2>
<p>The built-in benchmarks use <a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html">cargo bench</a>
and can be found in the <code>benches</code> directory for <code>core</code> and <code>alloc</code> and in <code>test</code> modules in <code>std</code>.</p>
<p>The benchmarks are automatically executed run in a loop by <code>Bencher::iter</code> to average the runtime over many loop-iterations.
For CPU-bound microbenchmarks the runtime of a single iteration should be in the range of nano- to microseconds.</p>
<p>To run a specific  can be invoked without recompiling rustc
via <code>./x bench library/&lt;lib&gt; --stage 0 --test-args &lt;benchmark name&gt;</code>.</p>
<p><code>cargo bench</code> measures wall-time. This often is good enough, but small changes such as saving a few instructions
in a bigger function can get drowned out by system noise. In such cases the following changes can make runs more
reproducible:</p>
<ul>
<li>disable incremental builds in <code>config.toml</code></li>
<li>build std and the benchmarks with <code>RUSTFLAGS_BOOTSTRAP=&quot;-Ccodegen-units=1&quot;</code></li>
<li>ensure the system is as idle as possible</li>
<li><a href="https://man7.org/linux/man-pages/man8/setarch.8.html">disable ASLR</a></li>
<li><a href="https://man7.org/linux/man-pages/man1/taskset.1.html">pinning</a> the benchmark process to a specific core</li>
<li>change the CPU <a href="https://wiki.archlinux.org/title/CPU_frequency_scaling#Scaling_governors">scaling governor</a>
to a fixed-frequency one (<code>performance</code> or <code>powersave</code>)</li>
<li><a href="https://wiki.archlinux.org/title/CPU_frequency_scaling#Configuring_frequency_boosting">disable clock boosts</a>,
especially on thermal-limited systems such as laptops</li>
</ul>
<h2 id="standalone-tests"><a class="header" href="#standalone-tests">Standalone tests</a></h2>
<p>If <code>x</code> or the cargo benchmark harness get in the way it can be useful to extract the benchmark into a separate crate,
e.g. to run it under <code>perf stat</code> or cachegrind.</p>
<p>Build the standard library and link <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#creating-a-rustup-toolchain">stage0-sysroot</a>
as rustup toolchain and then use that to build the standalone benchmark with a modified standard library.</p>
<p>If the std rebuild times are too long for fast iteration it can be useful to not only extract the benchmark but also
the code under test into a separate crate.</p>
<h2 id="running-under-perf-record"><a class="header" href="#running-under-perf-record">Running under perf-record</a></h2>
<p>If extracting the code into a separate crate is impractical one can first build the benchmark and then run it again
under <code>perf record</code> and then drill down to the benchmark kernel with <code>perf report</code>.</p>
<pre><code class="language-terminal ignore"># 1CGU to reduce inlining changes and code reorderings, debuginfo for source annotations
$ export RUSTFLAGS_BOOTSTRAP=&quot;-Ccodegen-units=1 -Cdebuginfo=2&quot;

# build benchmark without running it
$ ./x bench --stage 0 library/core/ --test-args skipallbenches

# run the benchmark under perf
$ perf record --call-graph dwarf -e instructions ./x bench --stage 0 library/core/ --test-args &lt;benchmark name&gt;
$ perf report
</code></pre>
<p>By renaming <code>perf.data</code> to keep it from getting overwritten by subsequent runs it can be later compared to runs with
a modified library with <code>perf diff</code>.</p>
<h2 id="comparing-assembly"><a class="header" href="#comparing-assembly">comparing assembly</a></h2>
<p>While <code>perf report</code> shows assembly of the benchmark code it can sometimes be difficult to get a good overview of what
changed, especially when multiple benchmarks were affected. As an alternative one can extract and diff the assembly
directly from the benchmark suite.</p>
<pre><code class="language-terminal ignore"># 1CGU to reduce inlining changes and code reorderings, debuginfo for source annotations
$ export RUSTFLAGS_BOOTSTRAP=&quot;-Ccodegen-units=1 -Cdebuginfo=2&quot;

# build benchmark libs
$ ./x bench --stage 0 library/core/ --test-args skipallbenches

# this should print something like the following
Running benches/lib.rs (build/x86_64-unknown-linux-gnu/stage0-std/x86_64-unknown-linux-gnu/release/deps/corebenches-2199e9a22e7b1f4a)

# get the assembly for all the benchmarks
$ objdump --source --disassemble --wide --no-show-raw-insn --no-addresses \
  build/x86_64-unknown-linux-gnu/stage0-std/x86_64-unknown-linux-gnu/release/deps/corebenches-2199e9a22e7b1f4a \
  | rustfilt &gt; baseline.asm

# switch to the branch with the changes
$ git switch feature-branch

# repeat the procedure above
$ ./x bench ...
$ objdump ... &gt; changes.asm

# compare output
$ kdiff3 baseline.asm changes.asm
</code></pre>
<p>This can also be applied to standalone benchmarks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-documentation"><a class="header" href="#how-to-write-documentation">How to write documentation</a></h1>
<p>This document explains how to write documentation for the std/core public APIs.</p>
<p>Let's start with some general information:</p>
<h3 id="when-to-use-inline-code-blocks"><a class="header" href="#when-to-use-inline-code-blocks">When to use inline code blocks</a></h3>
<p>Whenever you are talking about a type or anything code related, it should be in a
inline code block. As a reminder, a inline code block is created with backticks
(`). For example:</p>
<pre><code class="language-text">This a `Vec` and it has a method `push` which you can call by doing `Vec::push`.
</code></pre>
<h3 id="when-to-use-intra-doc-links"><a class="header" href="#when-to-use-intra-doc-links">When to use intra-doc links</a></h3>
<p>Intra-doc links (you can see the full explanations for the feature
<a href="https://doc.rust-lang.org/rustdoc/write-documentation/linking-to-items-by-name.html">here</a>)
should be used as much as possible whenever a type is mentioned.</p>
<p>Little note: when you are documenting an item, there is no need to link to it.
So, if you write documentation for the <code>String::push_str</code> method, there is
no need to link to the <code>push_str</code> method or the <code>String</code> type.</p>
<h3 id="code-blocks"><a class="header" href="#code-blocks">Code blocks</a></h3>
<p>With rustdoc, code blocks are tested (because they are treated as Rust code
blocks by default). It allows us to know if the documentation is up to date. As
such, please avoid using <code>ignore</code> as much as possible on code blocks! If you
want as a language other than Rust, simply set it in the code block tags:</p>
<pre><code class="language-text">```text
This is not rust code!
```
</code></pre>
<p>Some special cases:</p>
<ul>
<li>If the code example cannot be run (when documenting a I/O item for example),
use <code>no_run</code>.</li>
<li>If it is expected to fail, use <code>should_panic</code>.</li>
<li>If it is expected to fail compilation (which be quite rare!), use <code>compile_fail</code>.</li>
</ul>
<p>You can find more information about code blocks
<a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">here</a>.</p>
<h2 id="how-to-write-documentation-for-a-module"><a class="header" href="#how-to-write-documentation-for-a-module">How to write documentation for a module</a></h2>
<p>A module is supposed to contain &quot;similar&quot; items. As such, its documentation is
supposed to give an overview and eventually <strong>a base</strong> to understand what the
items it contains are doing.</p>
<p>You can take a look at the
<a href="https://doc.rust-lang.org/nightly/std/f32/index.html">f32 module</a> or at the
<a href="https://doc.rust-lang.org/nightly/std/fmt/index.html">fmt module</a> to see
good examples.</p>
<h2 id="how-to-write-documentation-for-functionsmethods"><a class="header" href="#how-to-write-documentation-for-functionsmethods">How to write documentation for functions/methods</a></h2>
<p>The basic format of each documented methods/functions should roughly look like this:</p>
<pre><code class="language-text">[explanations]

[example(s)]
</code></pre>
<h3 id="explanations"><a class="header" href="#explanations">Explanations</a></h3>
<p>By <code>explanations</code> we mean that the text should explain what the method and what
each of its arguments are for. Let's take this method for example:</p>
<pre><code class="language-rust ignore">pub fn concat_str(&amp;self, s: &amp;str) -&gt; String {
    if s.is_empty() {
        panic!(&quot;empty concat string&quot;);
    }
    format!(&quot;{}{}&quot;, self.string, s)
}</code></pre>
<p>The explanation should look like this:</p>
<pre><code class="language-text">Returns a new [`String`] which contains `&amp;self` content with `s` added at the end.
</code></pre>
<h3 id="panic"><a class="header" href="#panic">Panic?</a></h3>
<p>If the function/method can panic in certain circumstances, it must to be
mentioned! This explanation needs to be prepended by a <code>Panics</code> title:</p>
<pre><code class="language-text"># Panics

`concat_str` panics if `s` is empty.
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>As for the examples, they have to show the usage of the function/method. Just
like the <code>panic</code> section, they need to be prepended by a <code>Example</code> title (plural
if there is more than one).</p>
<p>It is better if you use <code>assert*!</code> macros at the end to ensure that the example
is working as expected. It also allows the readers to understand more easily
what the function is doing (or returning).</p>
<pre><code class="language-text"># Example

```
let s = MyType::new(&quot;hello &quot;);
assert_eq!(&quot;hello Georges&quot;, s.concat_str(&quot;Georges&quot;).as_str());
```
</code></pre>
<h2 id="how-to-write-documentation-for-other-items"><a class="header" href="#how-to-write-documentation-for-other-items">How to write documentation for other items</a></h2>
<p>It is mostly the same as for methods and functions except that the examples
are (strongly) recommended and not mandatory.</p>
<p>A good example often shows how to create the item.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-feature-lifecycle"><a class="header" href="#the-feature-lifecycle">The feature lifecycle</a></h1>
<h2 id="identifying-the-problem"><a class="header" href="#identifying-the-problem">Identifying the problem</a></h2>
<p>The first step before proposing any change to the standard library is to properly identify the problem that is trying to be solved. This helps to identify cases of the <a href="https://en.wikipedia.org/wiki/XY_problem">XY problem</a> where a better solution exists without needing any changes to the standard library.</p>
<p>For this reason it is helpful to focus on real problems that people are encountering, rather than theoretical concerns about API design.</p>
<h2 id="suitability-for-the-standard-library"><a class="header" href="#suitability-for-the-standard-library">Suitability for the standard library</a></h2>
<p>Unlike third party crates on crates.io, the Rust standard library is not versioned. This means that any stable API that is added can <em>never</em> be removed or modified in a backwards-incompatible way. For this reason, the standard library maintainers place a high bar on any change to the standard library API.</p>
<p>APIs that are well suited to the standard library are things that require language and/or compiler support, or that extend existing standard library types. Complex APIs that are expected to evolve over time (e.g. GUI frameworks) are a poor fit due to the lack of versioning.</p>
<p>The API Change Proposal process is intended to be a lightweight first step to
getting new APIs added to the standard library. The goal of this process is to
make sure proposed API changes have the best chance of success. The ACP process
accomplishes this by ensuring all changes are reviewed by the library API team,
who will evaluate the proposal and accept it if they are optimistic that the proposal will
be merged and pass its eventual FCP.</p>
<p>You can create an ACP in the <code>rust-lang/libs-team</code> repo using <a href="https://github.com/rust-lang/libs-team/issues/new?assignees=&amp;labels=api-change-proposal%2C+T-libs-api&amp;template=api-change-proposal.md&amp;title=%28My+API+Change+Proposal%29">this issue template</a>. This should include a sketch of the proposed API, but does not have to be the final design that will be implemented.</p>
<p>Note that an ACP is not strictly required: you can just go ahead and submit a pull request with an implementation of your proposed API, with the risk of wasted effort if the library team ends up rejecting this feature. However do note that this risk is always present even if an ACP is accepted, as the library team can end up rejecting a feature in the later parts of the stabilization process.</p>
<h2 id="api-design-exploration"><a class="header" href="#api-design-exploration">API design exploration</a></h2>
<p>Once a feature is deemed suitable for inclusion in the standard library, the exact design should be iterated on to find the best way to express it as a Rust API. This iteration should happen in community forums such as <a href="https://internals.rust-lang.org/">Rust internals</a> where all members of the community can comment and propose improvements.</p>
<p>Keep the following points in mind during the discussion:</p>
<ul>
<li>Try to achieve a balance between generality and specificity:
<ul>
<li>An overly general API tends to be difficult to use for common use cases, and has a complex API surface. This makes it difficult to review and maintain, and it may be a better fit for an external crate.</li>
<li>An overly specific API does not cover all common use cases, and may require further API changes in the future to accomodate these use cases.</li>
</ul>
</li>
<li>An alternative that should <em>always</em> be considered is simply adding this feature via a third party crate. This is even possible when adding new methods to standard library types by using extension traits.</li>
<li>In the case of &quot;convenience&quot; functions which are simply shorthands for something that is already possible with existing APIs, the cost of extending the standard library surface should be weighed against the ergonomic impact of the new functions.
<ul>
<li>For example, too many convenience methods on a type makes navigating the documentation more difficult.</li>
<li>Additionally, consider whether this method is likely to be deprecated in the future if a language-level improvement makes it unnecessary.</li>
</ul>
</li>
</ul>
<p>The library team itself is not directly involved in this discussion, but individual members may comment to provide feedback. If significant changes have occurred since the ACP, another one may be proposed at this point to have the design validated by the library API team.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Once the API design space has been explored, an implementation based on the favored solution should be proposed as a pull request to the <code>rust-lang/rust</code> repository.</p>
<p>The pull request should include a summary of the alternatives that were considered. This is helpful for reviewers since it avoids duplicating this exploration work as part of the review. A PR submitted without this may be closed with a request to explore more alternatives.</p>
<p>If an ACP has not been filed for the proposed feature, the PR will need to be reviewed by the library API team to determine its suitability for the standard library.</p>
<h2 id="tracking-and-stabilization"><a class="header" href="#tracking-and-stabilization">Tracking and stabilization</a></h2>
<p>Before a PR is merged, you will be asked to open a tracking issue which will track the progress of the feature until its <a href="development/stabilization.html">stabilization</a>.</p>
<p>There are two exceptions to this:</p>
<ul>
<li>Modifications of an existing unstable API can re-use the existing tracking issue for this API.</li>
<li>Changes that are instantly stable (e.g. trait implementations on stable types) do not need a tracking issue. However, such changes need extra scrutiny as there will be no chance to adjust the API during an unstable period.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stabilizing-features"><a class="header" href="#stabilizing-features">Stabilizing features</a></h1>
<ul>
<li><strong>Status:</strong> Current</li>
<li><strong>Last Updated:</strong> 2022-05-27</li>
</ul>
<p>Feature stabilization involves adding <code>#[stable]</code> attributes. They may be introduced alongside new trait impls or replace existing <code>#[unstable]</code> attributes.</p>
<p>Stabilization goes through the Libs FCP (Final Comment Period) process, which typically occurs on the tracking issue for the feature.</p>
<h2 id="when-is-an-fcp-appropriate"><a class="header" href="#when-is-an-fcp-appropriate">When is an FCP appropriate?</a></h2>
<p>Once an unstable feature's API design space (e.g. alternative APIs) has been fully explored with no outstanding concerns, anyone may push for its stabilization.</p>
<p>If you're unsure if a feature is ready for stabilization the first step should be to ask in the relevant tracking issue and get assistance from other participants in that discussion. In some cases the tracking issue may not have many other active participants, so if you're ever having trouble getting any feedback please ping one of the <a href="https://github.com/rust-lang/rust/blob/master/triagebot.toml">libs team reviewers</a> directly to request assistance.</p>
<h2 id="stabilization-report"><a class="header" href="#stabilization-report">Stabilization Report</a></h2>
<p>Once a feature is ready for stabilization the first step of the FCP process is writing a stabilization report. Stabilization reports are not mandatory but they are heavily encouraged, and may be mandated by library API team members if they feel it necessary. The purpose of stabilization reports is to help reviewers more quickly make decisions and to simplify the process of documenting stabilized APIs in release notes. Stabilization reports consist of three primary sections, an implementation history, an API summary, and an experience report.</p>
<p>The <strong>Implementation History</strong> section should summarize the initial discussion during the implementation PR, every change that has been made to the feature since the initial implementation, all issues that were raised during the lifetime of the feature, and how they were resolved.</p>
<p>The <strong>API Summary</strong> section should include a precise description of what APIs are being introduced to the standard libraries. This can often be a simple link back to the top level comment if it's up to date, but in some situations it may not be possible to edit the original tracking issue to fix outdated information, such as when the author of the stabilization report is not the author of the tracking issue itself.</p>
<p>The libs team maintains a tool for this called <a href="https://github.com/rust-lang/libs-team/tree/main/tools/unstable-api"><code>cargo unstable-api</code></a> that can be used to generate these API summaries in some cases. <em>Note</em> the current implementation of this tool is fragile and does not work in all cases. We hope to have a more permanent version of this tool in the future that is built on top of either rustdoc or rustc's own APIs.</p>
<p>The <strong>Experience Report</strong> section should include concrete usecases of users who have wanted to use the feature and who have tested that it works for their needs. The experience report should include a brief summary of the experience of using that feature. Ideally this would include links to commits or branches where the feature was integrated with their project, but this is not a requirement. Alternatively, users can provide usage examples of crates that export an identical API to the one being stabilized.</p>
<p>You can see an example of a stabilization report in <a href="https://github.com/rust-lang/rust/issues/88581#issuecomment-1054642118">#88581</a>.</p>
<h2 id="before-writing-a-pr-to-stabilize-a-feature"><a class="header" href="#before-writing-a-pr-to-stabilize-a-feature">Before writing a PR to stabilize a feature</a></h2>
<p>Check to see if a FCP has completed first. If not, either ping <code>@rust-lang/libs-api</code> if you're a member of the <code>rust-lang</code> organization,
or leave a comment asking about the status of the feature.</p>
<p>This will save you from opening a stabilization PR and having it need regular rebasing while the FCP process runs its course.</p>
<h2 id="partial-stabilizations"><a class="header" href="#partial-stabilizations">Partial Stabilizations</a></h2>
<p>When you only wish to stabilize a subset of an existing feature you should skip creating a new tracking issue and instead create a partial stabilization PR for the subset of the feature being stabilized.</p>
<p>If you're unsure if a feature is ready for partial stabilization the first step should be to ask in the relevant tracking issue and get assistance from other participants in that discussion. In some cases the tracking issue may not have many other active participants, so if you're ever having trouble getting any feedback please ping one of the <a href="https://github.com/rust-lang/rust/blob/master/triagebot.toml">libs team reviewers</a> directly to request assistance.</p>
<p>You can see an example of partially stabilizing a feature with tracking issue <a href="https://github.com/rust-lang/rust/issues/71146">#71146</a> and partial stabilization PR <a href="https://github.com/rust-lang/rust/pull/94640">#94640</a>.</p>
<h2 id="when-theres-const-involved"><a class="header" href="#when-theres-const-involved">When there's <code>const</code> involved</a></h2>
<p>Const functions can be stabilized in a PR that replaces <code>#[rustc_const_unstable]</code> attributes with <code>#[rustc_const_stable]</code> ones. The <a href="https://github.com/rust-lang/const-eval">Constant Evaluation WG</a> should be pinged for input on whether or not the <code>const</code>-ness is something we want to commit to. If it is an intrinsic being exposed that is const-stabilized then <code>@rust-lang/lang</code> should also be included in the FCP.</p>
<p>Check whether the function internally depends on other unstable <code>const</code> functions through <code>#[allow_internal_unstable]</code> attributes and consider how the function could be implemented if its internally unstable calls were removed. See the <em>Stability attributes</em> page for more details on <code>#[allow_internal_unstable]</code>.</p>
<p>Where <code>unsafe</code> and <code>const</code> is involved, e.g., for operations which are &quot;unconst&quot;, that the const safety argument for the usage also be documented. That is, a <code>const fn</code> has additional determinism (e.g. run-time/compile-time results must correspond and the function's output only depends on its inputs...) restrictions that must be preserved, and those should be argued when <code>unsafe</code> is used.</p>
<h2 id="stabilization-pr-for-library-features"><a class="header" href="#stabilization-pr-for-library-features">Stabilization PR for Library Features</a></h2>
<p>Once we have decided to stabilize a feature, we need to have a PR that actually makes that stabilization happen. These kinds of PRs are a great way to get involved in Rust, as they're typically small -- just updating attributes.</p>
<p>Here is a general guide to how to stabilize a feature -- every feature is different, of course, so some features may require steps beyond what this guide talks about.</p>
<h3 id="update-the-stability-attributes-on-the-items"><a class="header" href="#update-the-stability-attributes-on-the-items">Update the stability attributes on the items</a></h3>
<p>Library items are marked unstable via the <code>#[unstable]</code> attribute, like this:</p>
<pre><code class="language-rust ignore">#[unstable(feature = &quot;total_cmp&quot;, issue = &quot;72599&quot;)]
pub fn total_cmp(&amp;self, other: &amp;Self) -&gt; crate::cmp::Ordering { ... }</code></pre>
<p>You'll need to change that to a <code>#[stable]</code> attribute with the version set to the placeholder <code>CURRENT_RUSTC_VERSION</code>:</p>
<pre><code class="language-rust ignore">#[stable(feature = &quot;total_cmp&quot;, since = &quot;CURRENT_RUSTC_VERSION&quot;)]</code></pre>
<p>Note that other <code>#[stable]</code> attributes may contain spelled out version numbers, but you should not spell out any version number as it might get outdated by the time your pull request merges.</p>
<h3 id="remove-feature-gates-from-doctests"><a class="header" href="#remove-feature-gates-from-doctests">Remove feature gates from doctests</a></h3>
<p>All the doctests on the items being stabilized will be enabling the unstable feature, so now that it's stable those attributes are no longer needed and should be removed.</p>
<pre><code class="language-diff"> /// # Examples
 ///
 /// ```
-/// #![feature(total_cmp)]
-///
 /// assert_eq!(0.0_f32.total_cmp(&amp;-0.0), std::cmp::Ordering::Greater);
 /// ```
</code></pre>
<p>The most obvious place to find these is on the item itself, but it's worth searching the whole library.  Often you'll find other unstable methods that were also using it in their tests.</p>
<h3 id="remove-feature-gates-from-the-compiler"><a class="header" href="#remove-feature-gates-from-the-compiler">Remove feature gates from the compiler</a></h3>
<p>The compiler builds with nightly features allowed, so you may find uses of the feature there as well.  These also need to be removed.</p>
<pre><code class="language-diff"> #![feature(once_cell)]
 #![feature(never_type)]
-#![feature(total_cmp)]
 #![feature(trusted_step)]
 #![feature(try_blocks)]
</code></pre>
<h2 id="stabilization-pr-checklist"><a class="header" href="#stabilization-pr-checklist">Stabilization PR Checklist</a></h2>
<p>To stabilize a feature, follow these steps:</p>
<ol start="0">
<li>Create a stabilization report in the tracking issue for the feature being stabilized.</li>
<li>(Optional) For partial stabilizations, create a new partial stabilization PR for the subset of the issue being stabilized.</li>
<li>Ask a <strong>@rust-lang/libs-api</strong> member to start an FCP on the tracking issue and wait for the FCP to complete (with <code>disposition-merge</code>).</li>
<li>Change <code>#[unstable(...)]</code> to <code>#[stable(since = &quot;CURRENT_RUSTC_VERSION&quot;)]</code>. <code>CURRENT_RUSTC_VERSION</code> here is meant in a literal sense and not to be replaced with the spelled out version number.</li>
<li>Remove <code>#![feature(...)]</code> from any test or doc-test for this API. If the feature is used in the compiler or tools, remove it from there as well.</li>
<li>If applicable, change <code>#[rustc_const_unstable(...)]</code> to <code>#[rustc_const_stable(since = &quot;CURRENT_RUSTC_VERSION&quot;)]</code>.</li>
<li>Open a PR against <code>rust-lang/rust</code>.
<ul>
<li>Add the appropriate labels: <code>@rustbot modify labels: +T-libs-api</code>.</li>
<li>Link to the tracking issue by adding &quot;Closes #XXXXX&quot;.</li>
</ul>
</li>
</ol>
<p>You can see an example of stabilizing a feature with <a href="https://github.com/rust-lang/rust/issues/81656">tracking issue #81656 with FCP</a> and the associated <a href="https://github.com/rust-lang/rust/pull/84642">implementation PR #84642</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking changes</a></h1>
<p>Breaking changes should be avoided when possible.
<a href="https://rust-lang.github.io/rfcs/1105-api-evolution.html">RFC 1105</a> lays the foundations for what constitutes a breaking change.
Breakage may be deemed acceptable or not based on its actual impact,
which can be approximated with a <a href="https://github.com/rust-lang/crater/blob/master/docs/bot-usage.md">crater</a> run.</p>
<p>If the impact isn't too high, looping in maintainers of broken crates and submitting PRs to fix them can be a valid strategy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breakage-from-new-trait-impls"><a class="header" href="#breakage-from-new-trait-impls">Breakage from new trait impls</a></h1>
<p>A lot of PRs to the standard library are adding new impls for already stable traits,
which can break consumers in many weird and wonderful ways.
Below are some examples of breakage from new trait impls that
may not be obvious just from the change made to the standard library.</p>
<h2 id="inference-breaks-when-a-second-generic-impl-is-introduced"><a class="header" href="#inference-breaks-when-a-second-generic-impl-is-introduced">Inference breaks when a second generic impl is introduced</a></h2>
<p>Rust will use the fact that there's only a single impl for a generic trait during inference.
This breaks once a second impl makes the type of that generic ambiguous.
Say we have:</p>
<pre><code class="language-rust ignore">// in `std`
impl From&lt;&amp;str&gt; for Arc&lt;str&gt; { .. }</code></pre>
<pre><code class="language-rust ignore">// in an external `lib`
let b = Arc::from(&quot;a&quot;);</code></pre>
<p>then we add:</p>
<pre><code class="language-diff">impl From&lt;&amp;str&gt; for Arc&lt;str&gt; { .. }
+ impl From&lt;&amp;str&gt; for Arc&lt;String&gt; { .. }
</code></pre>
<p>then</p>
<pre><code class="language-rust ignore">let b = Arc::from(&quot;a&quot;);</code></pre>
<p>will no longer compile, because we've previously been relying on inference to figure out the <code>T</code> in <code>Box&lt;T&gt;</code>.</p>
<p>This kind of breakage can be ok, but a <a href="https://github.com/rust-lang/crater/blob/master/docs/bot-usage.md">crater</a> run should estimate the scope.</p>
<h2 id="deref-coercion-breaks-when-a-new-impl-is-introduced"><a class="header" href="#deref-coercion-breaks-when-a-new-impl-is-introduced">Deref coercion breaks when a new impl is introduced</a></h2>
<p>Rust will use deref coercion to find a valid trait impl if the arguments don't type check directly.
This only seems to occur if there's a single impl so introducing a new one may break consumers relying on deref coercion.
Say we have:</p>
<pre><code class="language-rust ignore">// in `std`
impl Add&lt;&amp;str&gt; for String { .. }

impl Deref for String { type Target = str; .. }</code></pre>
<pre><code class="language-rust ignore">// in an external `lib`
let a = String::from(&quot;a&quot;);
let b = String::from(&quot;b&quot;);

let c = a + &amp;b;</code></pre>
<p>then we add:</p>
<pre><code class="language-diff ignore">  impl Add&lt;&amp;str&gt; for String { .. }
+ impl Add&lt;char&gt; for String { .. }
</code></pre>
<p>then</p>
<pre><code class="language-rust ignore">let c = a + &amp;b;</code></pre>
<p>will no longer compile, because we won't attempt to use deref to coerce the <code>&amp;String</code> into <code>&amp;str</code>.</p>
<p>This kind of breakage can be ok, but a <a href="https://github.com/rust-lang/crater/blob/master/docs/bot-usage.md">crater</a> run should estimate the scope.</p>
<h2 id="fundamental-types"><a class="header" href="#fundamental-types"><code>#[fundamental]</code> types</a></h2>
<p>Type annotated with the <code>#[fundamental]</code> attribute have different coherence rules.
See <a href="https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html">RFC 1023</a> for details.
That includes:</p>
<ul>
<li><code>&amp;T</code></li>
<li><code>&amp;mut T</code></li>
<li><code>Box&lt;T&gt;</code></li>
<li><code>Pin&lt;T&gt;</code></li>
</ul>
<p>Typically, the scope of breakage in new trait impls is limited to inference and deref-coercion.
New trait impls on <code>#[fundamental]</code> types may overlap with downstream impls and cause other kinds of breakage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-changes-to-the-prelude"><a class="header" href="#breaking-changes-to-the-prelude">Breaking changes to the prelude</a></h1>
<p>Making changes to the prelude can easily cause breakage because it impacts all Rust code.
In most cases the impact is limited since prelude items have the lowest priority in name lookup (lower than glob imports), but there are two cases where this doesn't work.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Adding a new trait to the prelude causes new methods to become available for existing types.
This can cause name resolution errors in user code if a method with the same name is also available from a different trait.</p>
<p>For this reason, <a href="https://github.com/rust-lang/rust/issues/33417"><code>TryFrom</code> and <code>TryInto</code></a> were only added to the prelude for the 2021 edition despite being stabilized in 2019.</p>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Unlike other item types, rustc's name resolution for macros does not support giving prelude macros a lower priority than other macros, even if the macro is unstable.
As a general rule, avoid adding macros to the prelude except at edition boundaries.</p>
<p>This issues was encoutered when trying to land the <a href="https://github.com/rust-lang/rust/issues/82913"><code>assert_matches!</code> macro</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-documentation-changes"><a class="header" href="#breaking-documentation-changes">Breaking documentation changes</a></h1>
<p>First, short explanation about what a stability guarantee is: a statement in
the document which explains what the item is doing in a precise case. For
example:</p>
<ul>
<li>Showing precisely how a function on floats handles <code>NaN</code>.</li>
<li>Saying that a sort method has a particular running-time bound.</li>
</ul>
<p>So if a doc change updates/adds/removes a stability guarantee, it has to be
<strong>very</strong> carefully handled and needs to go through the
<a href="https://rustc-dev-guide.rust-lang.org/stabilization_guide.html?highlight=fcp#fcp">libs API team FCP</a>.</p>
<p>It can be circumvented by adding a <code># Current Implementation</code> section
<a href="https://github.com/rust-lang/rust/blob/4a8d2e3856c0c75c71998b6c85937203839b946d/library/alloc/src/slice.rs#L250">like done here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-to-add-must_use"><a class="header" href="#when-to-add-must_use">When to add <code>#[must_use]</code></a></h1>
<p>The <code>#[must_use]</code> attribute can be applied to types or functions when failing to explicitly consider them or their output is almost certainly a bug.</p>
<p>As an example, <code>Result</code> is <code>#[must_use]</code> because failing to consider it may indicate a caller didn't realise a method was fallible:</p>
<pre><code class="language-rust ignore">// Is `check_status` infallible? Or did we forget to look at its `Result`?
check_status();</code></pre>
<p>Operators like <code>saturating_add</code> are also <code>#[must_use]</code> because failing to consider their output might indicate a caller didn't realise they don't mutate the left-hand-side:</p>
<pre><code class="language-rust ignore">// A caller might assume this method mutates `a`
a.saturating_add(b);</code></pre>
<p>Combinators produced by the <code>Iterator</code> trait are <code>#[must_use]</code> because failing to use them might indicate a caller didn't realize <code>Iterator</code>s are lazy and won't actually do anything unless you drive them:</p>
<pre><code class="language-rust ignore">// A caller might not realise this code won't do anything
// unless they call `collect`, `count`, etc.
v.iter().map(|x| println!(&quot;{}&quot;, x));</code></pre>
<p>On the other hand, <code>thread::JoinHandle</code> isn't <code>#[must_use]</code> because spawning fire-and-forget work is a legitimate pattern and forcing callers to explicitly ignore handles could be a nuisance rather than an indication of a bug:</p>
<pre><code class="language-rust ignore">thread::spawn(|| {
    // this background work isn't waited on
});</code></pre>
<h2 id="for-reviewers"><a class="header" href="#for-reviewers">For reviewers</a></h2>
<p>Look for any legitimate use-cases where <code>#[must_use]</code> will cause callers to explicitly ignore values. If these are common then <code>#[must_use]</code> probably isn't appropriate.</p>
<p>The <code>#[must_use]</code> attribute only produces warnings, so it can technically be introduced at any time. To avoid accumulating nuisance warnings though ping <code>@rust-lang/libs</code> for input before adding new <code>#[must_use]</code> attributes to existing types and functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-specialization"><a class="header" href="#using-specialization">Using specialization</a></h1>
<p>Specialization is currently unstable. You can track its progress <a href="https://github.com/rust-lang/rust/issues/31844">here</a>.</p>
<p>We try to avoid leaning on specialization too heavily, limiting its use to optimizing specific implementations. These specialized optimizations use a private trait to find the correct implementation, rather than specializing the public method itself. Any use of specialization that changes how methods are dispatched for external callers should be carefully considered.</p>
<p>As an example of how to use specialization in the standard library, consider the case of creating an <code>Rc&lt;[T]&gt;</code> from a <code>&amp;[T]</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; From&lt;&amp;[T]&gt; for Rc&lt;[T]&gt; {
    #[inline]
    fn from(v: &amp;[T]) -&gt; Rc&lt;[T]&gt; {
        unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
    }
}</code></pre>
<p>It would be nice to have an optimized implementation for the case where <code>T: Copy</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: Copy&gt; From&lt;&amp;[T]&gt; for Rc&lt;[T]&gt; {
    #[inline]
    fn from(v: &amp;[T]) -&gt; Rc&lt;[T]&gt; {
        unsafe { Self::copy_from_slice(v) }
    }
}</code></pre>
<p>Unfortunately we couldn't have both of these impls normally, because they'd overlap. This is where private specialization can be used to choose the right implementation internally. In this case, we use a trait called <code>RcFromSlice</code> that switches the implementation:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; From&lt;&amp;[T]&gt; for Rc&lt;[T]&gt; {
    #[inline]
    fn from(v: &amp;[T]) -&gt; Rc&lt;[T]&gt; {
        &lt;Self as RcFromSlice&lt;T&gt;&gt;::from_slice(v)
    }
}

/// Specialization trait used for `From&lt;&amp;[T]&gt;`.
trait RcFromSlice&lt;T&gt; {
    fn from_slice(slice: &amp;[T]) -&gt; Self;
}

impl&lt;T: Clone&gt; RcFromSlice&lt;T&gt; for Rc&lt;[T]&gt; {
    #[inline]
    default fn from_slice(v: &amp;[T]) -&gt; Self {
        unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
    }
}

impl&lt;T: Copy&gt; RcFromSlice&lt;T&gt; for Rc&lt;[T]&gt; {
    #[inline]
    fn from_slice(v: &amp;[T]) -&gt; Self {
        unsafe { Self::copy_from_slice(v) }
    }
}</code></pre>
<p>Only specialization using the <code>min_specialization</code> feature should be used. The full <code>specialization</code> feature is known to be unsound.</p>
<h2 id="specialization-attributes"><a class="header" href="#specialization-attributes">Specialization attributes</a></h2>
<p>There are two unstable attributes that can be used to allow a trait bound in a specializing implementation that does not appear in the default implementation.</p>
<p><code>rustc_specialization_trait</code> restricts the implementations of a trait to be &quot;always applicable&quot;. Implementing traits annotated with <code>rustc_specialization_trait</code> is unstable, so this should not be used on any stable traits exported from the standard library. <code>Sized</code> is an exception, and can have this attribute because it already cannot be implemented by an <code>impl</code> block.
<strong>Note</strong>: <code>rustc_specialization_trait</code> only prevents incorrect monomorphizations, it does not prevent a type from being coerced between specialized and unspecialized types which can be important when specialization must be applied consistently. See <a href="https://github.com/rust-lang/rust/issues/85863">rust-lang/rust#85863</a> for more details.</p>
<p><code>rustc_unsafe_specialization_marker</code> allows specializing on a trait with no associated items. The attribute is <code>unsafe</code> because lifetime constraints from the implementations of the trait are not considered when specializing. The following example demonstrates a limitation of <code>rustc_unsafe_specialization_marker</code>, the specialized implementation is used for <em>all</em> shared reference types, not just those with <code>'static</code> lifetime. Because of this, new uses of <code>rustc_unsafe_specialization_marker</code> should be avoided.</p>
<pre><code class="language-rust ignore">#[rustc_unsafe_specialization_marker]
trait StaticRef {}

impl&lt;T&gt; StaticRef for &amp;'static T {}

trait DoThing: Sized {
    fn do_thing(self);
}

impl&lt;T&gt; DoThing for T {
    default fn do_thing(self) {
        // slow impl
    }
}

impl&lt;T: StaticRef&gt; DoThing for T {
    fn do_thing(self) {
        // fast impl
    }
}</code></pre>
<p><code>rustc_unsafe_specialization_marker</code> exists to allow existing specializations that are based on marker traits exported from <code>std</code>, such as <code>Copy</code>, <code>FusedIterator</code> or <code>Eq</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-to-inline"><a class="header" href="#when-to-inline">When to <code>#[inline]</code></a></h1>
<p>Inlining is a trade-off between potential execution speed, compile time and code size. There's some discussion about it in <a href="https://github.com/rust-lang/hashbrown/pull/119">this PR to the <code>hashbrown</code> crate</a>. From the thread:</p>
<blockquote>
<p><code>#[inline]</code> is very different than simply just an inline hint. As I mentioned before, there's no equivalent in C++ for what <code>#[inline]</code> does. In debug mode rustc basically ignores <code>#[inline]</code>, pretending you didn't even write it. In release mode the compiler will, by default, codegen an <code>#[inline]</code> function into every single referencing codegen unit, and then it will also add <code>inlinehint</code>. This means that if you have 16 CGUs and they all reference an item, every single one is getting the entire item's implementation inlined into it.</p>
</blockquote>
<p>You can add <code>#[inline]</code>:</p>
<ul>
<li>To public, small, non-generic functions.</li>
</ul>
<p>You shouldn't need <code>#[inline]</code>:</p>
<ul>
<li>On methods that have any generics in scope.</li>
<li>On methods on traits that don't have a default implementation.</li>
</ul>
<p><code>#[inline]</code> can always be introduced later, so if you're in doubt they can just be removed.</p>
<h2 id="what-about-inlinealways"><a class="header" href="#what-about-inlinealways">What about <code>#[inline(always)]</code>?</a></h2>
<p>You should just about never need <code>#[inline(always)]</code>. It may be beneficial for private helper methods that are used in a limited number of places or for trivial operators. A micro benchmark should justify the attribute.</p>
<h2 id="for-reviewers-1"><a class="header" href="#for-reviewers-1">For reviewers</a></h2>
<p><code>#[inline]</code> can always be added later, so if there's any debate about whether it's appropriate feel free to defer it by removing the annotations for a start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doc-alias-policy"><a class="header" href="#doc-alias-policy">doc alias policy</a></h1>
<p>Rust's documentation supports adding aliases to any declaration (such as a
function, type, or constant), using the syntax <code>#[doc(alias = &quot;name&quot;)]</code>. We
want to use doc aliases to help people find what they're looking for, while
keeping those aliases maintainable and high-value. This policy outlines the
cases where we add doc aliases, and the cases where we omit those aliases.</p>
<ul>
<li>We must have a reasonable expectation that people might search for the term
in the documentation search. Rust's documentation provides a name search, not
a full-text search; as such, we expect that people may search for plausible
names, but that for more general documentation searches they'll turn to a web
search engine.
<ul>
<li>Related: we don't expect that people are currently searching Rust
documentation for language-specific names from arbitrary languages they're
familiar with, and we don't want to add that as a new documentation search
feature; please don't add aliases based on your favorite language. Those
mappings should live in separate guides or references. We do expect that
people might look for the Rust name of a function they reasonably expect to
exist in Rust (e.g. a system function or a C library function), to try to
figure out what Rust called that function.</li>
</ul>
</li>
<li>The proposed alias must be a name we would plausibly have used for the
declaration. For instance, <code>mkdir</code> for <code>create_dir</code>, or <code>rmdir</code> for
<code>remove_dir</code>, or <code>popcnt</code> and <code>popcount</code> for <code>count_ones</code>, or <code>umask</code> for
<code>mode</code>. This feeds into the reasonable expectation that someone might search
for the name and expect to find it (&quot;what did Rust call <code>mkdir</code>&quot;).</li>
<li>There must be an obvious single target for the alias that is an <em>exact</em>
analogue of the aliased name. We will not add the same alias to multiple
declarations. (<code>const</code> and non-<code>const</code> versions of the same function are
fine.) We will also not add an alias for a function that's only somewhat
similar or related.</li>
<li>The alias must not conflict with the actual name of any existing declaration.</li>
<li>As a special case for stdarch, aliases from exact assembly instruction names
to the corresponding intrinsic function are welcome, as long as they don't
conflict with other names.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safety-comments"><a class="header" href="#safety-comments">Safety comments</a></h1>
<p>Using <a href="https://doc.rust-lang.org/stable/std/keyword.unsafe.html"><code>unsafe</code></a> blocks is often required in the Rust compiler or standard
library, but this is not done without rules: each <code>unsafe</code> block should have
a <code>SAFETY:</code> comment explaining why the block is safe, which invariants are
used and must be respected. Below are some examples taken from the standard
library:</p>
<h2 id="inside-unsafe-elements"><a class="header" href="#inside-unsafe-elements">Inside <code>unsafe</code> elements</a></h2>
<p>This one shows how an <code>unsafe</code> function can pass the requirements through to its
caller with the use of documentation in a <code># Safety</code> section while still having
more invariants needed that are not required from callers. <code>clippy</code> has a
lint for <code># Safety</code> sections by the way.</p>
<p><a href="https://github.com/rust-lang/rust/blob/a08f25a7ef2800af5525762e981c24d96c14febe/library/core/src/str/mod.rs#L278">See the example on github</a></p>
<pre><code class="language-rust ignore">/// Converts a mutable string slice to a mutable byte slice.
///
/// # Safety
///
/// The caller must ensure that the content of the slice is valid UTF-8
/// before the borrow ends and the underlying `str` is used.
///
/// Use of a `str` whose contents are not valid UTF-8 is undefined behavior.
///
/// ...
pub unsafe fn as_bytes_mut(&amp;mut self) -&gt; &amp;mut [u8] {
    // SAFETY: the cast from `&amp;str` to `&amp;[u8]` is safe since `str`
    // has the same layout as `&amp;[u8]` (only libstd can make this guarantee).
    // The pointer dereference is safe since it comes from a mutable reference which
    // is guaranteed to be valid for writes.
    unsafe { &amp;mut *(self as *mut str as *mut [u8]) }
}</code></pre>
<p>This example is for a function but the same principle applies to <code>unsafe trait</code>s
like <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> or <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a> for example, though they have no <code># Safety</code> section
since their entire documentation is about why they are <code>unsafe</code>.</p>
<p>Note that in the Rust standard library, <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> is active
and so each <code>unsafe</code> operation in an <code>unsafe</code> function must be enclosed in an
<code>unsafe</code> block. This makes it easier to review such functions and to document
their <code>unsafe</code> parts.</p>
<h2 id="inside-safe-elements"><a class="header" href="#inside-safe-elements">Inside <em>safe</em> elements</a></h2>
<p>Inside safe elements, a <code>SAFETY:</code> comment must not depend on anything from the
caller beside properly constructed types and values (i.e, if your function
receives a reference that is unaligned or null, it is the caller fault if it
fails and not yours).</p>
<p><code>SAFETY</code> comments in <em>safe</em> elements often rely on checks that are done before
the <code>unsafe</code> block or on type invariants, like a division by <code>NonZeroU8</code> would
not check for <code>0</code> before dividing.</p>
<p><a href="https://github.com/rust-lang/rust/blob/a08f25a7ef2800af5525762e981c24d96c14febe/library/core/src/str/mod.rs#L570">See the example on github</a></p>
<pre><code class="language-rust ignore">pub fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str) {
    // is_char_boundary checks that the index is in [0, .len()]
    if self.is_char_boundary(mid) {
        // SAFETY: just checked that `mid` is on a char boundary.
        unsafe { (self.get_unchecked(0..mid), self.get_unchecked(mid..self.len())) }
    } else {
        slice_error_fail(self, 0, mid)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reviewing-target-specific-code"><a class="header" href="#reviewing-target-specific-code">Reviewing target-specific code</a></h1>
<p>When reviewing target-specific code, depending on the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">tier</a> of the target in
question, different level of scrutiny is expected from reviewers.</p>
<p>For tier 1 targets, the reviewer should perform a full review of the code.
Essentially treat the code as <em>not</em> platform specific.</p>
<p>For tier 2 and tier 3 targets, the reviewer should confirm that the code:</p>
<ul>
<li>Only affects 1 or more of such targets (i.e., is truly target-specific)</li>
<li>Does not introduce new licensing hazards (e.g., license headers or similar)</li>
<li>Is either proposed by a target maintainer<sup class="footnote-reference"><a href="#1">1</a></sup> or has pinged and received +1s
from at least one target maintainer. Where no maintainer is present, look for
whether the author is reputable and/or affiliated with the target in some way
(e.g., authored original code, works for a company maintaining the target, etc.).</li>
</ul>
<p>Note that this review does <em>not</em> include checking for correctness or for code
quality. We lack the review bandwidth or expertise to perform detailed reviews
of tier 2 and tier 3 targets.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Target maintainers are listed for most targets in the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platform support</a> documentation.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-the-standard-library-uses-extension-traits-and-not-cfg-guarded-items"><a class="header" href="#why-the-standard-library-uses-extension-traits-and-not-cfg-guarded-items">Why the standard library uses extension traits (and not <code>cfg</code>-guarded items)</a></h1>
<p>A common pattern in the standard library is to put target-specific methods into
extension traits, rather than providing them as <code>cfg</code>-guarded methods directly
on objects themselves. For example, the many extension traits in
<a href="https://doc.rust-lang.org/std/os/unix/prelude/index.html"><code>std::os::unix::prelude</code></a>
provide UNIX-specific methods on standard types.</p>
<p>The standard library could, instead, provide these methods directly on the
standard types, guarded by <code>#[cfg(unix)]</code>. However, it does not do so, and PRs
adding <code>cfg</code>-guarded methods are often rejected.</p>
<p>Providing these methods via extension traits forces code to explicitly use
those extension traits in order to access the methods. This, effectively,
requires code to declare whether it depends on target-specific functionality,
either because the code is target-specific, or because it has appropriately
<code>cfg</code>-guarded code for different targets. Without these extension traits, code
could more easily use target-specific functionality &quot;accidentally&quot;.</p>
<p>This policy may change in the future if Rust develops better mechanisms for
helping code explicitly declare its portability, or lack of portability, before
accessing target-specific functionality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-and-may_dangle"><a class="header" href="#drop-and-may_dangle">Drop and <code>#[may_dangle]</code></a></h1>
<p>A generic <code>Type&lt;T&gt;</code> that manually implements <code>Drop</code> should consider whether a <code>#[may_dangle]</code> attribute is appropriate on <code>T</code>. The <a href="https://doc.rust-lang.org/nomicon/dropck.html">Nomicon</a> has some details on what <code>#[may_dangle]</code> is all about.</p>
<p>If a generic <code>Type&lt;T&gt;</code> has a manual drop implementation that may also involve dropping <code>T</code> then dropck needs to know about it. If <code>Type&lt;T&gt;</code>'s ownership of <code>T</code> is expressed through types that don't drop <code>T</code> themselves such as <code>ManuallyDrop&lt;T&gt;</code>, <code>*mut T</code>, or <code>MaybeUninit&lt;T&gt;</code> then <code>Type&lt;T&gt;</code> also <a href="https://rust-lang.github.io/rfcs/0769-sound-generic-drop.html#phantom-data">needs a <code>PhantomData&lt;T&gt;</code> field</a> to tell dropck that <code>T</code> may be dropped. Types in the standard library that use the internal <code>Unique&lt;T&gt;</code> pointer type don't need a <code>PhantomData&lt;T&gt;</code> marker field. That's taken care of for them by <code>Unique&lt;T&gt;</code>.</p>
<p>As a real-world example of where this can go wrong, consider an <code>OptionCell&lt;T&gt;</code> that looks something like this:</p>
<pre><code class="language-rust ignore">struct OptionCell&lt;T&gt; {
    is_init: bool,
    value: MaybeUninit&lt;T&gt;,
}

impl&lt;T&gt; Drop for OptionCell&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.is_init {
            // Safety: `value` is guaranteed to be fully initialized when `is_init` is true.
            // Safety: The cell is being dropped, so it can't be accessed again.
            unsafe { self.value.assume_init_drop() };
        }
    }
}</code></pre>
<p>Adding a <code>#[may_dangle]</code> attribute to this <code>OptionCell&lt;T&gt;</code> that didn't have a <code>PhantomData&lt;T&gt;</code> marker field opened up <a href="https://github.com/rust-lang/rust/issues/76367">a soundness hole</a> for <code>T</code>'s that didn't strictly outlive the <code>OptionCell&lt;T&gt;</code>, and so could be accessed after being dropped in their own <code>Drop</code> implementations. The correct application of <code>#[may_dangle]</code> also required a <code>PhantomData&lt;T&gt;</code> field:</p>
<pre><code class="language-diff ignore">struct OptionCell&lt;T&gt; {
    is_init: bool,
    value: MaybeUninit&lt;T&gt;,
+   _marker: PhantomData&lt;T&gt;,
}

- impl&lt;T&gt; Drop for OptionCell&lt;T&gt; {
+ unsafe impl&lt;#[may_dangle] T&gt; Drop for OptionCell&lt;T&gt; {
</code></pre>
<h2 id="for-reviewers-2"><a class="header" href="#for-reviewers-2">For reviewers</a></h2>
<p>If there's a manual <code>Drop</code> implementation, consider whether <code>#[may_dangle]</code> is appropriate. If it is, make sure there's a <code>PhantomData&lt;T&gt;</code> too either through <code>Unique&lt;T&gt;</code> or as a field directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-unsafe"><a class="header" href="#generics-and-unsafe">Generics and unsafe</a></h1>
<p>Be careful of generic types that interact with unsafe code. Unless the generic type is bounded by an unsafe trait that specifies its contract, we can't rely on the results of generic types being reliable or correct.</p>
<p>A place where this commonly comes up is with the <code>RangeBounds</code> trait. You might assume that the start and end bounds given by a <code>RangeBounds</code> implementation will remain the same since it works through shared references. That's not necessarily the case though, an adversarial implementation may change the bounds between calls:</p>
<pre><code class="language-rust ignore">struct EvilRange(Cell&lt;bool&gt;);

impl RangeBounds&lt;usize&gt; for EvilRange {
    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;usize&gt; {
        Bound::Included(if self.0.get() {
            &amp;1
        } else {
            self.0.set(true);
            &amp;0
        })
    }
    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;usize&gt; {
        Bound::Unbounded
    }
}</code></pre>
<p>This has <a href="https://github.com/rust-lang/rust/issues/81138">caused problems in the past</a> for code making safety assumptions based on bounds without asserting they stay the same.</p>
<p>Code using generic types to interact with unsafe should try convert them into known types first, then work with those instead of the generic. For our example with <code>RangeBounds</code>, this may mean converting into a concrete <code>Range</code>, or a tuple of <code>(Bound, Bound)</code>.</p>
<h2 id="for-reviewers-3"><a class="header" href="#for-reviewers-3">For reviewers</a></h2>
<p>Look out for generic functions that also contain unsafe blocks and consider how adversarial implementations of those generics could violate safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-library-team"><a class="header" href="#the-library-team">The Library Team</a></h1>
<p>The Rust standard library and the official <code>rust-lang</code> crates are
the responsibility of the Library Team.
The Library team makes sure the libraries are maintained,
PRs get reviewed, and issues get handled in time,
although that does not mean the team members are doing all the work themselves.
Many team members and other contributors are involved in this work,
and the team's main task is to guide and enable that work.</p>
<h2 id="the-library-api-team"><a class="header" href="#the-library-api-team">The Library API Team</a></h2>
<p>A very critical aspect of maintaining and evolving the standard library is its stability.
Unlike other crates, we can not release a new major version once in a while for backwards
incompatible changes. Every version of the standard library is semver-compatible
with all previous versions since Rust 1.0.</p>
<p>This means that we have to be very careful with additions and changes to the public interface.
We can deprecate things if necessary,
but removing items or changing signatures is almost never an option.
As a result, we are very careful with stabilizing additions to the standard library.
Once something is stable, we're basically stuck with it forever.</p>
<p>To guard the stability and prevent us from adding things we'll regret later,
we have a team that specifically focuses on the public API.
Every RFC and stabilization of a library addition/change goes through a FCP process
in which the members of the Library API Team are asked to sign off on the change.</p>
<p>The members of this team are not necessarily familiar with the implementation details
of the standard library, but are experienced with API design and understand the details
of breaking changes and how they are avoided.</p>
<h2 id="the-library-contributors"><a class="header" href="#the-library-contributors">The Library Contributors</a></h2>
<p>In addition to the two teams above, we also have the Library Contributors,
which is a somewhat more loosely defined team consisting of those who regularly contribute
or review changes to the standard libraries.</p>
<p>Many of these contributors have a specific area of expertise,
for example certain data structures or a specific operating system.</p>
<h2 id="team-membership"><a class="header" href="#team-membership">Team Membership</a></h2>
<p>The Library Team will privately discuss potential new members for itself and Library Contributors,
and extend an invitation after all members and the moderation team is on board with the potential addition.</p>
<p>See <a href="team/./membership.html">Membership</a> for details.</p>
<h3 id="r-permission"><a class="header" href="#r-permission">r+ permission</a></h3>
<p>All members of the Library Team, the Library API Team, and the Library Contributors
have the permission to approve PRs, and are expected to handle this with care.
See <a href="team/./reviewing.html">Reviewing</a> for details.</p>
<h3 id="high-five-rotation"><a class="header" href="#high-five-rotation">high-five rotation</a></h3>
<p>Some of the members of the team are part of the 'high-five rotation';
the list from which the high-five bot picks reviewers to assign new PRs to.</p>
<p>Being a member of one of the teams does not come with the expectation to be on this list.
However, members of this list should be on at least one of the three library teams.
See <a href="team/./reviewing.html">Reviewing</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meetings"><a class="header" href="#meetings">Meetings</a></h1>
<p>Currently, both the Library Team and the Library API Team have a weekly hour-long meeting.
Both meetings are open to non-members by default, although some might be (partially) private when agenda topics require that.</p>
<p>The meetings are held as video calls through <a href="https://meet.jit.si/">Jitsi</a>, but everyone is welcome to join without video or even audio.
If you want to participate in meeting discussions through text, you can do so through Jitsi's chat function.</p>
<p>Meetings and their agendas are announced in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/259402-t-libs.2Fmeetings">#t-libs/meetings</a> channel on Zulip.</p>
<p>Agendas are generated by the <a href="https://github.com/rust-lang/libs-team/tree/main/tools/agenda-generator"><code>fully-automatic-rust-libs-team-triage-meeting-agenda-generator</code></a>,
which will include all relevant issues and PRs, such as those tagged with <code>I-nominated</code> or <code>S-waiting-on-team</code>.</p>
<p>If you have any specific topics you'd like to have discussed in a meeting, feel free to open an issue on the <a href="https://github.com/rust-lang/libs-team/"><code>libs-team</code></a> repository
and mark it as <code>I-nominated</code> and <code>T-libs</code> or <code>T-libs-api</code>. Or just leave a message in the Zulip channel.</p>
<p>All the meetings, including those of the library working groups, can be found on our Google Calendar:</p>
<iframe width="100%" height="500px" src="https://calendar.google.com/calendar/embed?src=9kuu8evq4eh6uacm262k0phri8%40group.calendar.google.com"></iframe>
<p><a href="https://calendar.google.com/calendar/ical/9kuu8evq4eh6uacm262k0phri8%40group.calendar.google.com/public/basic.ics">ICS link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="membership"><a class="header" href="#membership">Membership</a></h1>
<h2 id="library-contributors"><a class="header" href="#library-contributors">Library Contributors</a></h2>
<p>Membership to Library Contributors can be offered by the Library Team once
a regular contributor has made a number of significant contributions over some period of time,
and has shown to have a good judgement on what changes are acceptable.</p>
<h2 id="the-library-team-and-library-api-team"><a class="header" href="#the-library-team-and-library-api-team">The Library Team and Library API Team</a></h2>
<p>The Library Team and Library API Team pick their own members,
although it's expected that new members come from the Library Contributors or another Rust team,
and have already been involved in relevant library work.</p>
<h2 id="the-process"><a class="header" href="#the-process">The process</a></h2>
<p>In all cases, the process of adding a new members goes as follows:</p>
<ol>
<li>A member of the Library (API) Team proposes the addition of a contributor on our private Zulip channel.
This proposal includes:
<ul>
<li>A short description of what this person has been working on; how they have been contributing.</li>
<li>A few specific examples of cases where this person clearly communicated their ideas.</li>
<li>A few specific examples that show this person understands what are and what aren't acceptable changes.<br />
Someone who makes significant contributions but usually needs to make large adjustments to their PRs might be a wonderful external contributor,
but might not yet be a good match for membership with review permissions expecting to judge other contributions.</li>
</ul>
</li>
<li>Every single team member is asked for their input. No team member must have any objections.
<ul>
<li>Objections are ideally shared with the entire team, but may also be shared privately with the team lead or the moderation team.</li>
<li>Objections ideally include examples showing behavior not in line with the expectations described under step 1
(or the code of conduct).</li>
</ul>
</li>
<li>The team lead reaches out to the moderation team to ask if they are aware of any objections.</li>
<li>Only once the team members and the moderation team agree, the new contributor is invited to join.</li>
<li>If the new contributor agrees too, a PR is sent to the <code>team</code> repository to add them.</li>
<li>A blog post is published in the Internals Blog with a short introduction of the new contributor.
The contents of this post can be based on some of the points brought up in the email from step 1.
The contents are first checked with the new contributor before it is published.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reviewing"><a class="header" href="#reviewing">Reviewing</a></h1>
<p>Every member of the Library Team, Library API Team, and Library Contributors has 'r+ rights'.
That is, the ability to approve a PR and instruct <a href="https://bors.rust-lang.org/"><code>@bors</code></a>
to test and merge it into Rust nightly.</p>
<p>If you decide to review a PR, thank you!
But please keep in mind:</p>
<ul>
<li>You are always welcome to review any PR, regardless of who it is assigned to.
However, do not approve PRs unless:
<ul>
<li>You are confident that nobody else wants to review it first. If you think someone else on the team would be a better person to review it, feel free to reassign it to them.</li>
<li>You are confident in that part of the code.</li>
<li>You are confident it will not cause any breakage or regress performance.</li>
<li>It does not change the public API, including any stable promises we make in documentation, unless there's a finished FCP for the change.
<ul>
<li>For unstable API changes/additions, it can be acceptable to skip the RFC process if the design is small and the change is uncontroversial.
Make sure to involve <code>@rust-lang/libs-api</code> on such changes.</li>
</ul>
</li>
</ul>
</li>
<li>Always be polite when reviewing: you are a representative of the Rust project, so it is expected that you will go above and beyond when it comes to the Code of Conduct.</li>
</ul>
<p>See <a href="https://forge.rust-lang.org/compiler/reviews.html">https://forge.rust-lang.org/compiler/reviews.html</a> for more information on reviewing.</p>
<h2 id="high-five-rotation-1"><a class="header" href="#high-five-rotation-1">High-five rotation</a></h2>
<p>Some of the members of the team are part of the 'high-five rotation';
the list from which the high-five bot picks reviewers to assign new PRs to.</p>
<p>Being a member of one of the teams does not come with the expectation to be on this list.
However, members of this list should be on at least one of the three library teams.</p>
<p>If the bot assigns you a PR for which you do not have the time or expertise to review it,
feel free to reassign it to someone else.
To assign it to another random person picked from the high-five rotation,
use <code>r? rust-lang/libs</code>.</p>
<p>If you find yourself unable to do any reviews for an extended period of time,
it might be a good idea to (temporarily) remove yourself from the list.
To add or remove yourself from the list, send a PR to change the
<a href="https://github.com/rust-lang/rust/blob/master/triagebot.toml">triagebot configuration file</a>.</p>
<h2 id="rolling-up"><a class="header" href="#rolling-up">Rolling up</a></h2>
<p>For library PRs, rolling up (<code>@bors r+ rollup</code>) is often fine,
in particular if it's only a new unstable addition or if it only touches docs.
PRs that impact performance should not be rolled up (<code>@bors rollup=never</code>),
PRs with subtle platform specific changes might also not be great candiates for rolling up.
See the <a href="https://forge.rust-lang.org/compiler/reviews.html#rollups">rollup guidelines</a> for more
details on when to rollup.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
